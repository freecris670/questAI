# Отчет о Рефакторинге: Внедрение Zustand для Управления Состоянием

Этот документ описывает процесс и результаты рефакторинга системы управления состоянием в веб-приложении (`apps/web`), в рамках которого была произведена миграция с `React Context` на `Zustand`.

## 1. Исходная Проблема

Изначально управление состоянием аутентификации пользователя было реализовано с помощью `React Context` (`AuthProvider`). Этот подход имел несколько недостатков:

- **Проблема Производительности:** Любое изменение в контексте (например, обновление статуса загрузки) приводило к повторному рендеру всех дочерних компонентов, подписанных на этот контекст, даже если они не использовали изменившиеся данные.
- **Prop Drilling:** Для управления состоянием UI (например, видимостью модального окна входа) приходилось "пробрасывать" состояние и функции для его изменения через несколько уровней компонентов (`MainHeader` -> `LoginModal`).
- **Избыточная Сложность:** `AuthProvider` был перегружен логикой: он одновременно хранил состояние, подписывался на события Supabase и содержал методы для взаимодействия с API.

## 2. План Рефакторинга

Был разработан следующий пошаговый план для миграции на `Zustand`:

1.  **Установка Зависимости:** Добавить `zustand` в `package.json` (этот шаг был пропущен по вашему указанию, но является необходимым).
2.  **Создание UI Стора:** Создать отдельный стор `useUIStore` для управления глобальными состояниями UI, такими как видимость модальных окон.
3.  **Создание Auth Стора:** Создать центральный стор `useAuthStore` для хранения состояния пользователя, профиля и статуса загрузки сессии.
4.  **Замена `AuthProvider`:**
    -   Создать компонент-слушатель `AuthHandler`, ответственный исключительно за синхронизацию событий аутентификации Supabase с `useAuthStore`.
    -   Заменить `AuthProvider` на `AuthHandler` в главном файле провайдеров (`apps/web/app/providers.tsx`).
5.  **Рефакторинг Хука `useAuth`:** Упростить хук `useAuth`, сделав его легковесной оберткой для доступа к данным из `useAuthStore` и методам Supabase/API.
6.  **Рефакторинг Компонентов:** Обновить `LoginModal` и `MainHeader`, чтобы они использовали новые сторы напрямую, устранив "prop drilling".
7.  **Восстановление Функциональности:** Вернуть в `useAuth` и `LoginModal` логику входа по email и паролю, интегрировав ее с новой архитектурой.

## 3. Реализация и Результаты

Все шаги плана были успешно выполнены.

### Новая Архитектура Управления Состоянием

Новый поток данных стал более чистым, предсказуемым и производительным.

```mermaid
graph TD
    subgraph "Клиентское Приложение (Next.js)"
        A[События Supabase Auth <br/> (SIGNED_IN, SIGNED_OUT)] ==> B(AuthHandler.tsx);
        B -- "Обновляет состояние" --> C((useAuthStore));
        
        subgraph "Компоненты"
          D[MainHeader.tsx] -- "Читает user, profile" --> C;
          E[LoginModal.tsx] -- "Вызывает signIn/signUp" --> F;
          G[Любой другой компонент] -- "Читает user, isLoggedIn" --> C;
        end

        D -- "Вызывает openLoginModal()" --> H((useUIStore));
        E -- "Читает isLoginModalOpen" --> H;
        
        F(useAuth.tsx) -- "Читает состояние" --> C;
    end

    subgraph "Серверная часть (NestJS)"
        I[API /auth/login]
        J[API /auth/register]
    end

    F -- "POST-запрос" --> I;
    F -- "POST-запрос" --> J;
    I -- "Возвращает JWT" --> F;
    J -- "Возвращает JWT" --> F;
    
    F -- "Устанавливает сессию с JWT" --> A;

```

### Ключевые Изменения в Коде

#### `useAuth.tsx`: До и После

Хук превратился из громоздкого провайдера контекста в простой и понятный набор селекторов и функций.

-   **Было:** ~250 строк кода, `useState`, `useEffect`, `createContext`, логика подписки, методы API.
-   **Стало:** ~100 строк кода, прямое взаимодействие с `useAuthStore` и `axios`.

#### `LoginModal.tsx`

Компонент стал полностью автономным.

-   **Было:** Принимал `isOpen` и `onClose` через пропсы. Управление состоянием было в родительском компоненте.
-   **Стало:** Использует `useUIStore` для контроля своей видимости и `useAuth` для выполнения логина. Не требует пропсов для управления состоянием.

#### `MainHeader.tsx`

Упростился вызов модального окна.

-   **Было:** `const [isLoginModalOpen, setIsLoginModalOpen] = useState(false); ... onClick={() => setIsLoginModalOpen(true)}`
-   **Стало:** `const { openLoginModal } = useUIStore(); ... onClick={openLoginModal}`

## 4. Выводы

Рефакторинг с использованием `Zustand` принес значительные улучшения:

-   ✅ **Производительность:** Устранены лишние повторные рендеры, так как компоненты теперь подписываются только на те части состояния, которые им действительно нужны.
-   ✅ **Разделение Ответственности (SoC):** Логика синхронизации с Supabase (`AuthHandler`), хранения состояния (`useAuthStore`) и взаимодействия с UI (`useUIStore`) четко разделена.
-   ✅ **Улучшение Developer Experience (DX):** Глобальное состояние стало доступно в любом компоненте без необходимости прокидывать пропсы. Код стал чище, проще для понимания и дальнейшей поддержки.
-   ✅ **Декомпозиция:** Компоненты (`LoginModal`) стали более независимыми и переиспользуемыми. 